//今日23.9.23  结构体
//定义： struct ___（相当于自己创建的数据类型）  ___ID  { 成员列表};
//#include <iostream>
//using namespace std;
//struct student
//{
//	string name; //成员列表内记录学生的名字 年龄 成绩
//	int age;
//	int score;
//};
//
//void print(const student* stu)
//{
//	//stu->age = 0; //此时，stu的值是不可以修改的,避免了误操作
//}
//int main()
//{
//	student stu1 = { "小学生",18,100 };
//	cout << "学生的名字为："<< stu1.name <<" 学生的年龄为："<< stu1.age <<  endl;
//	//当想使用成员列表内的内容 可以用  名字.成员列表
//	student* point = &stu1;
//	cout << "学生的成绩为:" << point->score << endl;
//	//当使用指针存储结构体的地址时，若想调出使用，应该用 -> 符号 指向所需要的成员
//
//	//知识点：当传递结构体时，如果采用值传递，需要重新复制一份，会很耗费内存。
//	//所以我们应该采用地址传递。与此同时，为了避免在函数中误操作修改值，可以采用常量指针。
//	print(&stu1);
//	system("pause");
//	return 0;
//}

//结构体做参数函数
//#include <iostream>
//using namespace std;
//
//struct student
//{
//	string name;
//	int age;
//	int score;
//};
////1.值传递
//void print(student s)
//{
//	//若在此处修改形参的数值，对实参无影响。
//	cout << "学生的姓名：" << s.name << " 学生的年龄：" << s.age << " 学生的分数：" << s.score << endl;
//}
////2.地址传递
//void print1(student * p)
//{
//	//若在此处修改数值，寻址以后会修改实参。所以说应根据情况来选择使用。
//	cout << "学生的姓名：" << p->name << " 学生的年龄：" << p->age << " 学生的分数：" << p->score << endl;
//}
//int main()
//{
//	student s1 = { "小李",18,100 };
//	print(s1);//值传递打印
//	print1(&s1);//地址传递打印
//	system("pause");
//	return 0;
//}

////结构体案例1 
////总共有三个老师，每个老师带五个学生，请创建老师和学生的结构体，前者中有老师的名字和带的学生，后者中有学生名字和成绩
////然后再创建一个数组包含这三个老师，再用函数输入老师和学生的结构体内容，最后输出学生和老师的内容。
//#include <iostream>
//using namespace std;
//#include <ctime>
////1.分别创建老师和学生的结构体，包含各自的内容
//struct student {
//	string name;
//	int score;
//};
//struct teacher{
//	string name;
//	student stdarr[5];
//};
//
//void give(teacher tea[], int len)//函数传入数组的地址和长度
//{
//	srand((unsigned int)time(NULL));
//	string nameseed = "ABCDE";
//	for(int i=0;i<3;i++)
//	{
//		tea[i].name = "Teacher_";
//		tea[i].name += nameseed[i];
//		for (int j = 0; j < 5; j++)
//		{
//			tea[i].stdarr[j].name = "Student_";
//			tea[i].stdarr[j].name += nameseed[j];
//			tea[i].stdarr[j].score = rand()%61+40;// 0~60 +40 =40~100
//		}
//	}
//
//}
//void printInform(teacher tea[],int len)
//{
//	for(int i=0;i<len;i++)
//	{
//		cout << "第" << i+1 << "个老师的名字是:" << tea[i].name << endl;
//		for(int j=0;j<5;j++)
//		{
//			cout << "\t他的第" << j+1 << "个学生的名字是:" << tea[i].stdarr[j].name
//				<< "该学生的成绩是:" << tea[i].stdarr[j].score << endl;
//		}
//	}
//}
//int main()
//{
//	//2.创建数组存放三名老师
//	teacher tea[3];
//	int len = sizeof(tea) / sizeof(tea[0]);
//	//3.通过函数给每个老师和学生赋值
//	give(tea,len);
//	//4.打印出老师和学生分别的数据
//	printInform(tea,len);
//	system("pause");
//	return 0;
//}


//9.24日结构体练习
//利用冒泡排序对结构体数组排序。
#include <iostream>
//using namespace std;
////1.设计英雄的结构体 成员列表包括姓名年龄性别
//struct hero
//{
//	string name;
//	int age;
//	string sex;
//};
//void bubble(hero harr[], int len) //参数列表有 结构体数组的地址 数组的长度
//{
//	for (int i = 0; i < len-1; i++)
//	{
//		for (int j = 0; j < len - 1 - i; j++)
//		{
//			if (harr[j].age > harr[j + 1].age)
//			{
//				////[1]名字交换
//				//string Name = harr[j].name;
//				//harr[j].name = harr[j + 1].name;
//				//harr[j + 1].name = Name;
//				////[2]年龄交换
//				//int temp = harr[j].age;
//				//harr[j].age = harr[j + 1].age;
//				//harr[j + 1].age = temp;
//				////[3]性别交换
//				//string Sex = harr[j].sex;
//				//harr[j].sex = harr[j + 1].sex;
//				//harr[j + 1].sex = Sex;
//				//【4】此处也可以一次性传导
//				hero temp = harr[j];
//				harr[j] = harr[j + 1];
//				harr[j + 1] = temp;
//			}
//		}
//	}
//}
//void printH(hero harr[], int len)
//{
//	for (int i = 0; i < len;i++)
//	{
//		cout << "\t第"<<i+1 << "个英雄的名字是：" << harr[i].name << " 年龄是：" << harr[i].age
//			 << " 性别是：" << harr[i].sex << endl;
//	}
//}
//int main()
//{
//	//2.创建一个数组存放五名英雄
//	hero Harr[5] = {
//		{"刘备",23,"男"},
//		{"关羽",22,"男"},
//		{"张飞",20,"男"},
//		{"赵云",21,"男"},
//		{"貂蝉",19,"女"}
//	};
//	cout << "排序前的打印结果：" << endl;
//	int len = sizeof(Harr) / sizeof(Harr[0]);
//	printH(Harr, len);
//	//3.使用冒泡排序按照年龄做升序排序
//	bubble(Harr,len);
//	//cout << Harr[0].age << Harr[0].name << Harr[0].sex << endl;//检测一下冒泡排序的正确性
//	//4.使用函数打印排序后的结果
//	cout << "排序后的打印结果：" << endl;
//	printH(Harr,len);
//	system("pause");
//	return 0;
//}

//#include <iostream>
//using namespace std;
//
//void mySwap01(int& a, int& b)  //参数列表接收类似以下形式 int&a=a,int&b=b 
//								//引用的形式 可改变实参 id可以一样
//{
//	int temp = a;
//	a = b;
//	b = temp;
//}
//
//void printA(const int& a) //在此处加个const 将文件变成了只读状态，这样常量不能修改
//{
//	//a = 10;这种情况就会报错
//	cout << a << endl; 
//} 
//
//int& printb(int& a)
//{
//	a = 100;   //此处的a是形参 放在栈区，当函数运行结束后，系统会保留一次以后删除该内存上的内容
//	return a;  //所以应避免这样返回操作， 类同野指针。
//}
//int& ref()
//{
//	static int a = 20;
//	return a;
//}
//int main()
//{
//	//今日学习内容1.内存四区
//	//1.1 代码区  此区全是二进制的机器指令
//	//1.2 全局区  此处存放的是 全局变量(函数外声明的数据类型) 静态变量(static) 和常量 
//	//            其中常量包含的是全局常量(函数外声明的const+数据类型)和字符串常量("hello world")
//	//
//	// 1.3 栈区 由编译器控制，程序结束后自动删除。存放的是局部变量和函数的形参等
//	// 1.4 堆区 由程序员控制，可以利用new delete关键字控制
//	//栈区和堆区是在程序开始以后才开始出现
//	//堆区举例
//	//int * p=new int(0); //关键字new 数据类型 (数字的大小)； 
//	////在系统的堆区开辟了一块空间用于存储括号内的数字，该表达式整体的值是该空间的地址，所以用指针去接收
//	//cout << *p << endl;
//	//*p = 20;
//	//cout << *p << endl;//其中的数字也是可以修改的
//	////如果想开辟数组的话 格式是 关键字new 数据类型 [数组元素的个数]
//	//int* arr = new int[4];
//	//for(int i=0;i<4;i++)
//	//{
//	//	arr[i] =i;
//	//	cout << arr[i] << endl;
//	//}
//	//delete p;    //格式：  delete 接收内存空间的指针;
//	//delete arr;
//	////cout << *p << endl; 删除地址后，无法再访问。
//	////cout<<arr[0]<<endl;删除地址后，无法再访问。
//
//	//今日2.引用  用处：相当于给数据起了个别名
//	//2.1 定义 
//	//int a = 10; //开辟一块空间叫做a
//	//int& b = a;//给a的那块空间起个别名，叫做b 
//	//cout << "a=" << a << endl;
//	//cout << "b=" << b << endl;//所以通过b的名字 也可以去寻找那块空间
//	//b = 20;
//	//cout <<"a=" << a << endl;
//	//cout << "b=" << b << endl;
//	//int &b=10;  这种是错误的，右端应该是一块合法的空间。
//
//	//2.2注意：引用必须进行初始化，且初始化后，不可更改为别人的别名。
//
//	//2.3 利用引用可以代替指针使用。 也可以通过形参改变实参的数字
//	//int a = 0;
//	//int b = 1;
//	//mySwap01(a, b);
//	//cout << "a=" << a << " b=" << b << endl;
//
//	//2.4 引用的本质 其实就是指针变量  int* const p 可以修改p所对应的数值，但是不能修改地址。
//	//int a = 0;
//	//int& b = a;  //在编译器内部相当于 int * b=&a; 相当于把a的地址存放在了b的内部
//	//b = 10;//编译器在内部自动转换 该步骤等同于 *b=10 ,下同.
//	//cout << b << endl;
//	 
//	//2.5常量引用   //此处理解类同于结构体指针传递的时候 
//	//int a = 100;
//	//printA(a); //为了避免误操作修改实参，采用常量引用 也就是在形参内引用前加个const
//
//	//2.6引用做函数的返回值
//	//【1】不要返回局部变量
//	//int a = 0;
//	//int&b=printb(a);
//	//cout << "a=" << b << endl;
//	//【2】可以作为等号的左值
//	//int& a = ref();
//	//ref() = 50;  //相当于返回的是a值，可以对其进行赋值。
//	//cout <<a<< endl;
//	system("pause");
//	return 0;
//}
